/*
 * 제어자(modifier)
 * -클래스, 변수 또는 메서드의 선언부와 함께 사용되어 부가적인 의미를 부여
 * 1.접근제어자 : public, protected, (default) private
 *  -한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.
 *  -주로 접근 제어자를 제일 왼쪽에 둔다.
 *  -private : 같은 클래스 내에서만 접근이 가능하다.
 *  -(default) : 같은 패키지 내에서만 접근이 가능하다.
 *  -protected : 같은 패키지 내에서, 다른 패키지의 자손클래스에서 접근이 가능
 *  -public : 접근 제한이 전혀 없다.
 *  -클래스는 public, (default)를 사용하고, 멤버는 네 가지 접근제어자 모두 사용한다.
 * 2.그 외 제어자 : static, abstract, native, transient, synchronized, volatile, strictfp
 */

/*
 * static - 클래스의, 공통적인
 * -인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지하지만, 
 *  클래스변수는 하나의 변수를 모든 인스턴스가 공유하므로 인스턴스에 관계없이 같은 값을 갖는다.
 * -static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에
 *  인스턴스를 생성하지 않고도 사용할 수 있다.
 *  
 * static 멤버변수
 * -모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
 * -클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
 * -클래스가 메모리에 로드될 때 생성된다.
 * 
 * static 메서드
 * -인스턴스를 생성하지 않고도 호출이 가능하다.
 * -static메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.
 * 
 * 인스턴스 멤버를 사용하지 않는 메서드는 static을 붙여서 static메서드를 선언하는 것을 고려하자.
 * -가능하다면 static메서드로 하는 것이 인스턴스를 생성하지 않고도 호출이 가능해서 편하다.
 */

class StaticTest {
	static int width= 200;			// 클래스변수(static변수)
	static int heigth= 120;			// 클래스변수(static변수)
	
	static {						// 클래스 초기화 블럭
		// static변수의 복잡한 초기화 수행(문장)
	}
	
	static int max(int a, int b) {	// 클래스 메서드(static 메서드)
		return a> b? a : b; // iv 사용불가, 인스턴스 메서드 사용불가
	}
	// iv멤버는 객체 생성후에야 쓸 수 있다. static멤버는 객체 생성없이 사용가능
}

/*
 * final - 마지막의, 변경될 수 없는
 * -변수에 사용하면 값을 변경할 수 없는 상수가 되고, 메서드에 사용하면 오버라이딩(상속받은 조상메서드를
 *  덮어 쓰는 것)을 할 수 없게 되며 클래스에 사용하면 자신을 확장하는 지손클래스를 정의하지 못하게 된다.
 * -final이 사용될 수 있는 곳 : 클래스, 메서드, 멤버변수, 지역변수
 * 
 * final 클래스
 * -변경할 수 없는 클래스, 확장될 수 없는 클래스가 된다.
 * -final이 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
 * -대표적인 예로 String(보안문제)과 Math(static 메서드 집합)가 있다.
 * 
 * final 메서드
 * -변경될 수 없는 메서드
 * -final로 지정된 메서드는 오버라이딩(상속받은 메서드의 내용을 변경)을 통해 재정의 될 수 없다.
 * 
 * final 멤버변수, final 지역변수
 * -변수 앞에 final이 붙으면 값을 변경할 수 없는 상수가 된다.
 */

final class FinalTest {				// 조상이 될 수 없는 클래스
	final int MAX_SIZE= 10;			// 값을 변경할 수 없는 멤버변수(상수)
	
	final void getMaxSize() {		// 오버라이딩 할 수 없는 메서드(변경불가)
		final int LV= MAX_SIZE;		// 값을 변경할 수 없는 지역변수(상수)
		return;
	}
}

/*
 * abstract - 추상의, 미완성의
 * -메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상메서드를 선언하는데 사용된다.
 * -클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.
 * -abstract가 사용될 수 있는 곳 : 클래스, 메서드
 * 
 * abstract 클래스
 * -클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
 * 
 * abstract 메서드
 * -선언부가 작성하고 구현부는 작성하지 않은 추상메서드임을 알린다.
 */

abstract class AbstractTest {		// 추상클래스(추상메서드를 포함한 클래스)
	abstract void move();			// 추상메서드(구현부가 없는 메서드)
}

//	AbstractTest a= new AbstractTest();  // 에러. 추상클래스의 인스턴스생성(제품생산) 불가
	// 추상클래스(미완성 설계도)를 상속받아서 완전한 클래스(완성 설계도)를 만든 후에 객체생성 가능

public class Practise2 {
	public static void main(String[] args) {
		
	}
}